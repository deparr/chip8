
Chip8 opcodes from [Wikipedia](https://en.wikipedia.org/wiki/CHIP-8#Opcode_table)

```
0NNN 	Call 	Calls machine code routine (RCA 1802 for COSMAC VIP) at address NNN. Not necessary for most ROMs.[24]
00E0 	Display	disp_clear() 	Clears the screen.[24]
00EE 	Flow 	return; 	Returns from a subroutine.[24]
1NNN 	Flow 	goto NNN; 	Jumps to address NNN.[24]
2NNN 	Flow 	*(0xNNN)() 	Calls subroutine at NNN.[24]
3XNN 	Cond 	if (Vx == NN) 	Skips the next instruction if VX equals NN (usually the next instruction is a jump to skip a code block).[24]
4XNN 	Cond 	if (Vx != NN) 	Skips the next instruction if VX does not equal NN (usually the next instruction is a jump to skip a code block).[24]
5XY0 	Cond 	if (Vx == Vy) 	Skips the next instruction if VX equals VY (usually the next instruction is a jump to skip a code block).[24]
6XNN 	Const 	Vx = NN 	Sets VX to NN.[24]
7XNN 	Const 	Vx += NN 	Adds NN to VX (carry flag is not changed).[24]
8XY0 	Assig 	Vx = Vy 	Sets VX to the value of VY.[24]
8XY1 	BitOp 	Vx |= Vy 	Sets VX to VX or VY. (bitwise OR operation).[24]
8XY2 	BitOp 	Vx &= Vy 	Sets VX to VX and VY. (bitwise AND operation).[24]
8XY3[a]	BitOp 	Vx ^= Vy 	Sets VX to VX xor VY.[24]
8XY4 	Math 	Vx += Vy 	Adds VY to VX. VF is set to 1 when there's an overflow, and to 0 when there is not.[24]
8XY5 	Math 	Vx -= Vy 	VY is subtracted from VX. VF is set to 0 when there's an underflow, and 1 when there is not. (i.e. VF set to 1 if VX >= VY and 0 if not).[24]
8XY6[a] BitOp 	Vx >>= 1 	Shifts VX to the right by 1, then stores the least significant bit of VX prior to the shift into VF.[b][24]
8XY7[a] Math 	Vx = Vy - Vx 	Sets VX to VY minus VX. VF is set to 0 when there's an underflow, and 1 when there is not. (i.e. VF set to 1 if VY >= VX).[24]
8XYE[a] BitOp 	Vx <<= 1 	Shifts VX to the left by 1, then sets VF to 1 if the most significant bit of VX prior to that shift was set, or to 0 if it was unset.[b][24]
9XY0 	Cond 	if (Vx != Vy) 	Skips the next instruction if VX does not equal VY. (Usually the next instruction is a jump to skip a code block).[24]
ANNN 	MEM 	I = NNN 	Sets I to the address NNN.[24]
BNNN 	Flow 	PC = V0 + NNN 	Jumps to the address NNN plus V0.[24]
CXNN 	Rand 	Vx = rand() & NN 	Sets VX to the result of a bitwise and operation on a random number (Typically: 0 to 255) and NN.[24]
DXYN 	Display draw(Vx, Vy, N) 	Draws a sprite at coordinate (VX, VY) that has a width of 8 pixels and a height of N pixels. Each row of 8 pixels is read as bit-coded starting from memory location I; I value does not change after the execution of this instruction. As described above, VF is set to 1 if any screen pixels are flipped from set to unset when the sprite is drawn, and to 0 if that does not happen.[24]
EX9E 	KeyOp 	if (key() == Vx) 	Skips the next instruction if the key stored in VX is pressed (usually the next instruction is a jump to skip a code block).[24]
EXA1 	KeyOp 	if (key() != Vx) 	Skips the next instruction if the key stored in VX is not pressed (usually the next instruction is a jump to skip a code block).[24]
FX07 	Timer 	Vx = get_delay() 	Sets VX to the value of the delay timer.[24]
FX0A 	KeyOp 	Vx = get_key() 	A key press is awaited, and then stored in VX (blocking operation, all instruction halted until next key event).[24]
FX15 	Timer 	delay_timer(Vx) 	Sets the delay timer to VX.[24]
FX18 	Sound 	sound_timer(Vx) 	Sets the sound timer to VX.[24]
FX1E 	MEM 	I += Vx 	Adds VX to I. VF is not affected.[c][24]
FX29 	MEM 	I = sprite_addr[Vx] 	Sets I to the location of the sprite for the character in VX. Characters 0-F (in hexadecimal) are represented by a 4x5 font.[24]
FX33 	BCD 
FX55 	MEM 	reg_dump(Vx, &I) 	Stores from V0 to VX (including VX) in memory, starting at address I. The offset from I is increased by 1 for each value written, but I itself is left unmodified.[d][24]
FX65 	MEM 	reg_load(Vx, &I) 	Fills from V0 to VX (including VX) with values from memory, starting at address I. The offset from I is increased by 1 for each value read, but I itself is left unmodified.[d][24]
```
